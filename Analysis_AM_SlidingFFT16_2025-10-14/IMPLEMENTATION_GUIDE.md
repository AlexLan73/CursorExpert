# Рекомендации коллеге (исполнителю)

## Два режима интеграции
- A) Фьюзинг внутрь ваших ядер N (16…256):
  1) В начале ядра: загрузить окно x[0..N−1] со стартом s=2·w (паддинг 0).
  2) Выполнить ваши «бабочки» FFTN.
  3) Сделать fftshift и записать сразу в B[L][w][k].
- B) Без изменения ядер: отдельные шаги
  1) gather→workspace [total_windows, N]
  2) batched FFTN (ваши ядра или cuFFT)
  3) пост‑ядро fftshift→B

## Когда что выбирать
- N≤64: A обычно быстрее.
- N=128…256: чаще A; проверить профилем.
- N=512…1024: B проще и стабилен, профилировать с cuFFT vs собственное ядро.

## Мэппинг и память
- «1 окно = 16 потоков» (или 32 потока на 2 окна/варп) для N=16.
- Несколько окон на блок для больших N.
- Twiddle в __constant__, shared для промежуточных стадий.
- Писать сразу в B после fftshift.

## Интерфейс слоя
- process_sliding_fft(rayCount=4, rayLen=S, N=16, step=2, pad=true) → B.
- Выбор режима A/B по N или профайлером.

## Инварианты и тесты
- nW = ceil((S−N)/2)+1; последний блок дополняется нулями.
- Сверка нескольких окон с эталоном.
- Проверка порядка B[L][w][k] и k‑fftshift.
