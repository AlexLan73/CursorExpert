# Технический анализ: Скользящий FFT16, шаг=2, fftshift

## Варианты
- A) По‑окну (много запусков): просто, но большой launch‑overhead — не брать.
- B) 4 смещённых потока (0,2,4,6): сложный мердж индексов, профит мал — не первично.
- C) Батч‑ядро (рекомендовано): «gather→FFT16→fftshift→store B» за один проход, один большой запуск на все окна.
- D) Persistent kernel: избыточно для этой задачи.
- E) cuFFT batched: годится как альтернатива для больших N, потребует gather и fftshift отдельно.

## Индексация и формулы
- Число окон на луч: nW = ceil((S−N)/2) + 1.
- Старт окна: s = 2·w.
- Сэмпл: x[t] = (s+t < S) ? X[L][s+t] : 0.
- FFT16 → y[k]; fftshift: yshift[k] = y[(k+8) mod 16].
- Результат: B[L][w][k] = yshift[k], k=0..15.

## Почему C лучше
- Один проход по памяти, минимум трафика и запусков.
- Высокая утилизация SM за счёт большого батча окон.
- Простая и строгая индексация: w = s/2 без дополнительных сдвигов.

## Карта распараллеливания
- N=16: «1 окно = 16 потоков» (или 32 потока на 2 окна/варп).
- N=32…64: аналогично, несколько окон на блок.
- Грид: total_windows по всем лучам.
- Twiddle в __constant__, бабочки в shared, запись B с fftshift.

## Проверки корректности
- Паддинг крайнего окна нулями до N.
- Энергия до/после fftshift одинакова.
- Сверка с эталонной однопоточной реализацией для нескольких окон.
